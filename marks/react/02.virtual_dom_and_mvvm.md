# 虚拟 DOM vs MVVM

MVVM 系框架（Angular、VUE）：

- 通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作；
- MVVM 的变化检查时数据层面的，而 React 的检查时 DOM 结构层面的。
- MVVM 的性能根据变动检查的实现原理有所不同
  - Angular 的`脏检查`使得任何变动都有固定的 O(watcher count)代价；
  - VUE 采用`依赖收集`，在 js 和 DOM 层面都是 O(change);

在初始化阶段：

- MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行对应一个 ViewModel 实例，或者是一个稍微轻量一些的利用原型基层的`scope` 对象；
  - 在创建时，是有一定代价的；
  - 初始化渲染时，要比虚拟 DOM 慢；
- MVVM 面临的问题，在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效的复用已经创建的 ViewModel 实例和 DOM 元素了？
  - 假如没有任何复用方面的优化，由于数据几乎是全新的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后在进行一次渲染；
  - 这就是为什么 Angular/Knockout 实现都相对比较慢；
  - React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功；
  -

脏检查 MVVM

脏检查 MVVM 是检查数据的变化，保留对真实节点的操作。脏检查机制是对所有固定 watch count 进行计算变化，所以在小修改变化中慢。但是全部数据发生更新时候，速度远远快于其他模式；

依赖收集 MVVM

数据收集是每个组件都存在自己的 ViewModel 实例，每个 ViewModel 实例功能：

- 对数据监听；
- 真实 DOM 树的操作；
- 自己的数据作用域；

当数据发生修改时，自会触发自身作用域下的变动。所以在小修改时比较快，在初始化渲染和大部分数据更更新时就比较慢，因为创建大量的 ViewModel 实例需要消耗性能是一定的。所以现在大部分 MVVM 依赖收集模式框架需要的面对问题是如何复用之前创建的 ViewModel；

如何进行 MVVM 模式的列表渲染进行优化？

在 Angular 和 VUE 中我们可以用`:key="index"` (旧版本使用`track-by="index"` )等方式提示框架这是一个可以复用的 ViewModel 实例，框架就会知道当前 ViewModel 实例只是数组数据的内容发生变化，DOM 结构并没有发生改变。直接根绝数据里的位置进行复用修改显示数据。

性能比较
在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。

初始渲染：Virtual DOM > 脏检查 >= 依赖收集
小量数据更新：依赖收集 >> Virtual DOM + 优化 > 脏检查（无法优化） > Virtual DOM 无优化
大量数据更新：脏检查 + 优化 >= 依赖收集 + 优化 > Virtual DOM(无法/无需优化) >> MVVM 无优化
